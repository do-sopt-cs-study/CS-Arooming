# 📑 프로세스 주소 공간: 코드, 데이터, 스택 영역의 관리

## 🚧 프로세스 주소 공간

- 프로그램 실행 시, OS가 실행 파일의 명령을 읽어 프로세스를 생성하고 메모리를 할당하는 공간
- 효율적인 데이터 공유와 메모리 사용을 위해 메모리 영역을 나눠 실행함.

![](https://velog.velcdn.com/images/paki1019/post/8a324210-b15b-49d8-aba0-6084917c200d/image.png)

### 👀 Code(Text)

- `실행할 프로그램의 코드`를 저장하는 영역
- 프로그램을 실행시키는 **실행 파일 내의 명령어**들이 위치하는 공간 → `Read-Only`로 지정됨 → 수정 불가
- 컴파일 시 결정됨.
- **같은 프로그램**으로 실행된 여러 프로세스는  **동일한 코드**를 가짐.
    - Hex 파일이나 Bin 파일로 구성

### 👀 Data

- 프로그램의 `전역변수, static(정적)변수, 배열, 구조체 등`이 저장되는 영역
- 전역변수와 static 값을 참조한 코드는 컴파일 후 data의 주소 값을 가리킴.
- 한 프로세스 내 여러 스레드가 공통으로 **data 영역 공유**
    - 중복된 내용을 여러 번 할당 X → 하나의 공간으로 구성 → 메모리 사용량 절약 !
- 실행 중 변수 수정 가능 → `Read-Write`로 지정됨.
- 프로그램의 시작과 함께 할당, 프로그램 종료 시 소멸
- 초기화된 데이터 → data 영역에 저장
    - 초기화되지 않은 데이터 → **BSS(Block Stated Symbol)** 영역에 저장

### 👀 Stack

- `함수의 실행을 마치고 복귀할 주소, 데이터(지역변수, 매개변수, 반환값)`를 **임시로** 저장하는 공간
- 각 함수는 LIFO(Last In First Out) 구조로 실행됨.
    - **컴파일 타임**에 크기 결정됨.
    - 재귀함수가 너무 깊게 호출되거나 함수가 너무 많은 지역변수를 가지고 있어 stack 영역 초과 시, **stack overflow** 에러 발생
- heap 영역과 반대로 메모리 `상위 주소 → 하위주소` 방향으로 추가 할당.
- 실행 중 변수 수정 가능 → `Read-Write`로 지정됨.
- 함수의 호출과 함께 할당, 함수 호출 완료 시 소멸
    - stack frame: 스택 영역에 저장되는 함수 호출 정보
- 프로그램이 자동으로 사용하는 임시 메모리 영역

### 👀 Heap

- 동적 할당(malloc(), new 등)을 위한 메모리 영역
- **런타임**에 크기가 결정됨.
- stack 영역과 반대로 메모리 `하위 주소 → 상위 주소` 방향으로 추가 할당.
- 주로 객체가 저장됨.
    - Garbage Collector에 의해 정리됨.