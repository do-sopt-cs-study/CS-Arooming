# 📑 동기화의 필요성: 레이스 컨디션과 교착 상태(데드락)

## 🔥 공유 자원

- 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등
- 공동으로 이용 → 누가 언제 데이터를 읽고 쓰느냐에 따라 결과가 달라짐

## 🔥 경쟁 조건(Race Condition)

- 2개 이상의 프로세스/ 스레드가 공유 자원을 서로 사용하려고 경함(Race)하는 현상
- 멀티 스레드 환경에서는 프로세스 내의 모든 자원을 공유할 수 있기 때문에, 동기화 문제 발생!
    
    <aside>
    ❓ 1. 값이 0인 변수 `x`
    2. 스레드 A, B
    3. 스레드 `A`는 변수 x를 읽어옴
    4. 스레드 `B`는 변수 x를 읽어옴
    5. 스레드 `A`는 변수 `x + 10`의 값을 저장
    6. 스레드 `B`는 변수 `x + 1`의 값을 저장
    
    </aside>
    
    → 이 때 결과는 11이 아닌, 1이 들어가게 됨!
    → 즉, 경쟁 조건(Race Condition): 동시에 공유 자원에 접근함으로서 `자원의 일관성을 해치는` 결과가 발생하는 것.
    

## 🔥 교착 상태(DeadLock)

- 2개 이상의 프로세스/ 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
- 무한히 다음 자원을 기다리게 되는 상태
- 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생

![데드락.png](https://t1.daumcdn.net/cfile/tistory/243E89355714C26E28)

- P1과 P2가 리소스 1, 2 둘 다를 얻어야한다고 가정할 때,
t1: P1 → 리소스 1을 얻음/ P2 → 리소스 2를 얻음
t2: P1 → 리소스 2를 기다림/ P1 → 리소스 1을 기다림
- 서로 원하는 리소스가 상대에게 할당되어 있기 때문에 두 프로세스는 무한히 다음 자원을 기다리게 됨
    - 이러한 상태를 DeadLock이라고 함 !!

### 🚰 교착 상태(DeadLock) 발생 조건

- 4가지 조건이 모두 성립해야 데드락 발생
    - 한 가지 조건이라도 성립하지 않으면 데드락 문제 해결 가능

1. 상호 배제(Mutual Exclusion)
    - 자원은 한 번에 한 프로세스만 사용 가능
    - 사용중인 자원을 다른 프로세스가 사용하려면 요청 자원이 해제될 때까지 기다려야 함.
2. 점유 대기(Hold and Wait)
    - 최소 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함.
3. 비선점(No Preemption)
    - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음.
4. 순환 대기(Circular Wait)
    - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함.

### 🚰 교착상태(DeadLock) 해결법

- 교착상태 `예방(Prevention)`
- 교착상태 `회피(Avoidance)`
- 교착상태를 `탐지(Detection)`&`회복(Recovery)`

1. **교착상태 예방(Prevention)**
- 교착 상태 조건 중 하나를 제거하면서 해결(자원 낭비가 매우 심함)
    - 자원의 상호 배제 조건 부정
        - 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 함.
        - 추후 동기화 관련 문제 발생 가능성 O
    - 점유 대기 조건 부정
        - 프로세스 실행에 필요한 자원을 한꺼번에 요구 → 허용할 때까지 작업 보류
        - 또 다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 함.
    - 비선점 조건 부정
        - 이미 다른 프로세스에게 할당된 자원에 선점권이 없다고 가정할 때, 높은 우선 순위의 프로세스가 해당 자원을 선점할 수 있도록 함.
    - 순환 대기 조건 부정
        - 자원을 순환 형태로 대기하지 않도록 일정한 한 방향으로만 자원을 요구할 수 있도록 함.

1. **교착상태 회피(Avoidance)**
- 교착상태 발생 시, 피해나가는 방법
    - 은행원 알고리즘(Banker’s Algorithm)
        - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래
        - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착상태 회피
        - 안정 상태면 자원할당, 아니면 다른 프로세스들의 자원 해지까지 대기
    - 안정 상태(Safe State)
        - 시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있는 상태
    - 안전 순서(Safe Sequence)
        - 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때, 데드락이 발생하지 않는 순서를 찾을 수 있는 순서

1. **교착상태 탐지(Detection) & 회복(Recovery)**
- 교착상태가 되도록 허용한 다음 회복시키는 방법
    - 교착상태 탐지(Detection)
        - 자원 할당 그래프를 통해 교착상태 탐지
        - 자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함.
    - 교착상태 회복(Recovery)
        - 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법
            
            > **프로세스 중단시키기**
            - 교착상태에 빠진 모든 프로세스 중단시키기
            - 교착상태가 제거될 때까지 하나씩 프로세스 중단시키기
            
            자원 선점 방법
            - 교착 상태의 프로세스가 점유하고 있는 자원 선점 → 다른 프로세스에게 할당 (해당 프로세스 일시정지)
            - 우선 순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원 선점
            >